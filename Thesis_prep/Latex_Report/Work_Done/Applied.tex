\section{Applied $\pi$-Calculus}
%Short - examples of the applied $\pi$-calculus 
%\begin{itemize}
%  \item General about Applied Pi Calculus, and how it differs from pi calculus (terms; in particular for security protocols)
%  \item Examples of applied pi calculus (handshake protocol?)
%  \item ProVerif - automatic symbolic protocol verifier
%\end{itemize}

% missing link from the unformal way of Alice and Bob notation (but more convenient), to the more formal applied pi-calculus
% "The previous chapter describes how messages exchanged in cryptographic protocols can be represented as terms. In this chapter, we discuss how the protocols themselves can be modelled."
The applied pi-calculus (ref. Abadi and Fournet, 2001) is based upon the language pi-calculus, but offers a more convenient use for modelling security protocols to be specified, by allowing for a more wide variety of complex primitives. It is used for describing and analysing security protocols, as it provides a more intuitive process syntax for detailing the actions of the participants in a protocol \autocite{AplliedPiCalsulus2010}. This is done by introducing a rich term algebra for modelling the cryptographic operations used in security protocols, where function symbols represent cryptographic protocols. 

Tools such as ProVerif \autocite{ProVerif} uses a syntax closely related to the applied pi-calculus, and offers a way of automated reasoning about the security properties found in cryptographic protocols. The ProVerif tool is however not used for this report, but is mentioned as it is often used when analysing security protocols, and will most likely be used in the following thesis.\\
%- The properties of these primitives are modelled by equations \\ 

%"The applied pi calculus (...) is a language for describing concurrent processes and their interactions". \\
\subsection{Syntax}
As mentioned, the applied pi-calculus is not restricted to communication names, but offers processes where they output terms representing messages instead. The applied pi-calculus has two two types of process, the \textit{plain} and \textit{extended} processes. First we describe the grammar for the \textit{plain} process, as shown below (fig. ref?).:  %(by \citeauthor{AplliedPiCalsulus2010}): 
\begin{center}
	\begin{tabular} { l l }
 		$P,\ Q,\ R$ ::= & plain processes \\ 
 		\quad $|$ 0 & null process \\  
 		\quad $|$ $P\ |\ Q$ & parallel composition \\
 		\quad $|$ !$P$ & replication \\
		\quad $|$ $\nu n.P$ & name restriction \\
		\quad $|$ if \textit{M = N} then \textit{P} else \textit{Q} & conditional \\
		\quad $|$ $u(x).P$ & message input \\
		\quad $|$ $\overline{u}\langle M\rangle .P $ & message output 
	\end{tabular}
\end{center}
The 0 process is the process that does nothing; $P\ |\ Q$ is the parallel composition of the processes \textit{P} and \textit{Q} executed in parallel; !$P$ is the replication of \textit{P} that allows for an infinite composition of $P\ |\ P\ |\ ...,$ which is often used for illustrating an unbound number of sessions; Name restriction $\nu n.P$ acts as a binder which generates a restricted name \textit{n} inside \textit{P}. This is often used for capturing fresh random numbers such as nonces and keys, or private channels, which we will see later when we apply it to the NS Protocol; The conditional if \textit{M = N} then \textit{P} else \textit{Q} is how we know from normal conditioning, where it behaves as \textit{P} whenever \textit{M = N} (representing equality), and as \textit{Q} otherwise; Last we have the message input and output, where $u(x).P$ expects an input on channel \textit{u} and binds it to variable \textit{x} in \textit{P}, and $\overline{u}\langle M\rangle .P $ outputs term \textit{M} on channel \textit{u} and then behaves as \textit{P}. It should be noted that message input and output will also we written as in\textit{(u, x).P} and out\textit{(u, M).P} as done by \citeauthor{DBLP:journals/ftpl/CortierK14} \\
\iffalse
Plain processes are generated by the grammar given
in Figure 5.1, where t, t1, t2, . . . range over terms, n over names, x over
variables and u is a meta-variable that stands for either a name or a
variable of channel sort. 
\fi

% Extension
Processes are extended with \textit{active substitutions} to capture the knowledge exposed to the
adversarial environment: (rewirte)
\begin{center}
	\begin{tabular} { l l }
 		\textit{A, B, C} ::= & extended processes \\ 
 		\quad $|$ \textit{P} & plain process \\  
 		\quad $|$ $A\ |\ B$ & parallel composition \\
		\quad $|$ $\nu n.A$ & name restriction \\
		\quad $|$ $\nu x.P$ & variable restriction \\
		\quad $|$ $\{ \sfrac{M}{x} \}$ & active substitution
	\end{tabular}
\end{center}
With \textit{active substitution} we allow for \textit{M} to be available in the environment through the 'handle' \textit{x}. In other words, \textit{M} can now be replaced by \textit{x} in every process it is related to, and is only controlled by the variable restriction, i.e. $\nu x.(\{\sfrac{M}{x}\}\ |\ P)$ is exactly the same as $x$ = $M$ in $P.$\\ 
%Terms

With terms we use function symbols to capture primitives such as encryption or decryption used by cryptographic protocols. It should be noted that functions with arity 0 are what we define as constants.
For terms we apply function symbols to names, variable and other terms as such: 
\begin{center}
	\begin{tabular} { l l }
 		L, M, N, T, U, V ::= & terms \\ 
 		\quad $|$ a, b, c,...,k,...,m, n,..,s & names \\  
 		\quad $|$ x, y, z & variables \\
 		\quad $|$ g(M$_{1}$,..,M$_{l}$) & function application
		%\caption{Fig. 1.1}
		%\label{tbl:excel-table}
	\end{tabular}
\end{center}
Terms represent messages that are exhanged, and are inductively build over a finite set of variables \textit{X = \{x, y, z\}} and.... Variable can represent any term. Names are used to represent atomic values, such as key and nonces. A term is \textit{ground} if it dies not contain any variables. (rewrite!)
TODO: description (maybe first)

\subsection{Re-visiting the Needham-Schroeder Protocol}
Having established an understanding og the applied pi-calculus and its grammar, we now use it model the previously mentioned Needham-Schroeder public key protocol.\\

To make this distinction explicit we parametrize the processes representing the initiator and responder with the keys of the agents who execute the role. (rewrite!!):
\begin{center}
\includegraphics[width=0.65\textwidth, angle=0]{Graphics/P_A.pdf}
\end{center}
First Alice generates a fresh random nonce and binds it to \textit{n$_a$}, the process then continues to output the first message of an asymmetric encryption on channel \textit{c}. Next she waits for a input message on the same channel, and binds the message to variable \textit{x}. She then checks wether the message matches her previously sent nonce \textit{n$_a$} shown as the conditional. For readability the \textit{x} is then bound to a local variable \textit{n$_xb$}, representing the nonce received by the sender (Bob). Last she sendt out a message again on channel c. \\

\noindent The dual of the process can now be modelled from the responders point of view:
\begin{center}
\includegraphics[width=0.55\textwidth, angle=0]{Graphics/P_B.pdf}
\end{center}

\noindent Combining the two processes, we are able to model the Needham-Schroeder public key protocol as a whole: 
\citeauthor{DBLP:journals/ftpl/CortierK14} (Describe P$_{A}$ and P$_{B}$ first):
\begin{center}
\includegraphics[width=0.6\textwidth, angle=0]{Graphics/P1_nspk.pdf}
\end{center}
This however represent the naive model of the protocol, so to add the Lowe fix, as mentioned earlier i then report, we add the identity to the encryptions: (TODO: needs further explanation)
\begin{center}
\includegraphics[width=0.6\textwidth, angle=0]{Graphics/P5_nspk.pdf}
\end{center}
TODO: smooth transition to the next chapter + don't forget reference to article!


% Extra
% Handshake protocol
\iffalse
First of, we look at the simple Handshake protocol used for setting the parameters for communication between two devices, such as the old dial-up modem or when connecting to a USB.  \\
Handshake protocol with applied pi-calculus as illustred by \citeauthor{AplliedPiCalsulus2010}:
\begin{center}
\includegraphics[width=0.75\textwidth, angle=0]{Graphics/Handshake.pdf}
\end{center}
\fi
